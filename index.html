<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Shuffle & Recall - Local PNG Cards</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>canvas { background: #1e1e1e; }</style>
</head>
<body class="dark bg-gray-900 text-white font-sans h-screen overflow-hidden">
  <div id="uiContainer" class="absolute inset-0 flex flex-col items-center justify-center z-10 p-4">
    <h1 class="text-2xl sm:text-3xl md:text-4xl font-bold mb-4">Shuffle & Recall üß†üÉè</h1>
    <button id="startBtn" class="bg-cyan-400 hover:bg-cyan-300 text-black font-semibold py-2 px-6 rounded">Mulai Game</button>
  </div>

  <div id="result" class="mt-4 text-lg font-semibold text-center"></div>
  <div id="countdown" class="absolute inset-0 flex items-center justify-center text-6xl font-bold text-cyan-300 z-20 hidden">30</div>

  <div id="gameOver" class="absolute inset-0 hidden flex flex-col items-center justify-center z-30">
    <div class="text-6xl font-bold text-red-500">GAME OVER üí•</div>
    <button onclick="location.reload()" class="mt-4 bg-white text-black py-2 px-6 rounded">Coba Lagi</button>
  </div>

  <div id="nextPhase" class="absolute inset-0 hidden flex items-center justify-center z-30">
    <button id="readyBtn" class="bg-green-400 text-black py-3 px-6 text-xl font-bold rounded">Saya Siap!</button>
  </div>

  <canvas id="gameCanvas" class="w-full h-full block"></canvas>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';

    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setClearColor(0x1e1e1e);
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 6;

    const ambient = new THREE.AmbientLight(0xffffff, 0.9);
    const dir = new THREE.DirectionalLight(0xffffff, 1);
    dir.position.set(0, 5, 5);
    scene.add(ambient, dir);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const suits = ['S','H','D','C'];
    const ranks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
    const deck = suits.flatMap(s => ranks.map(r => `${r}${s}`));

    function getPngUrl(label) {
      const rank = label.slice(0, -1).toUpperCase();
      const suit = label.slice(-1).toUpperCase();
      const suitName = { S: 'spade', H: 'heart', D: 'diamond', C: 'club' }[suit];
      const rankName = { 'A': '1', 'J': 'jack', 'Q': 'queen', 'K': 'king' }[rank] || rank;
      return `png/2x/${suitName}_${rankName}.png`;
    }

    const CARD_BACK_URL = 'png/2x/back.png';
    let cards = [], shown = [], currentClick = 0;

    async function createCard(label) {
      const geo = new THREE.PlaneGeometry(1, 1.4);
      const tFront = await new Promise(r => new THREE.TextureLoader().load(getPngUrl(label), r));
      const tBack = await new Promise(r => new THREE.TextureLoader().load(CARD_BACK_URL, r));
      const matFront = new THREE.MeshStandardMaterial({ map: tFront, side: THREE.DoubleSide });
      const matBack = new THREE.MeshStandardMaterial({ map: tBack, side: THREE.DoubleSide });

      const mesh = new THREE.Mesh(geo, matFront);
      mesh.userData = { flipped: false, frontMat: matFront, backMat: matBack };
      return mesh;
    }

    function flipCard(card) {
      card.material = card.userData.flipped ? card.userData.frontMat : card.userData.backMat;
      card.userData.flipped = !card.userData.flipped;
    }

    function shuffle(arr) {
      for (let i = arr.length -1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    async function startGame() {
      document.getElementById('uiContainer').classList.add('hidden');
      scene.clear();
      scene.add(ambient, dir);
      cards = []; shown = [];
      document.getElementById('result').textContent = '';

      const deckCopy = [...deck];
      shuffle(deckCopy);
      shown = deckCopy.slice(0, 5);

      for (let i = 0; i < shown.length; i++) {
        const c = await createCard(shown[i]);
        c.position.x = (i - 2) * 1.2;
        scene.add(c);
        cards.push(c);

        // üü° Tambahkan marker angka di atas setiap kartu
        const marker = document.createElement('div');
        marker.className = 'absolute text-yellow-300 font-bold text-2xl';
        marker.style.pointerEvents = 'none';
        marker.style.transform = 'translate(-50%, -50%)';
        marker.id = `order${i}`;
        marker.textContent = `${i + 1}`;
        document.body.appendChild(marker);

        function updatePosition() {
          const vector = c.position.clone().project(camera);
          const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-vector.y * 0.5 + 0.5) * window.innerHeight - 70; // sedikit di atas kartu
          marker.style.left = `${x}px`;
          marker.style.top = `${y}px`;
        }

        c.userData.orderMarker = marker;
        c.userData.updateOrderMarker = updatePosition;
      }

      let timeLeft = 30;
      const countdownEl = document.getElementById('countdown');
      countdownEl.textContent = timeLeft;
      countdownEl.classList.remove('hidden');

      const interval = setInterval(() => {
        timeLeft--;
        countdownEl.textContent = timeLeft;
        if (timeLeft <= 0) {
          clearInterval(interval);
          countdownEl.classList.add('hidden');

          cards.forEach(flipCard);

          // üîÑ Acak posisi X kartu setelah dibalik
          const shuffled = [...cards];
          shuffle(shuffled);
          shuffled.forEach((c, i) => {
            c.position.x = (i - 2) * 1.2 + (Math.random() * 0.3 - 0.15); // variasi posisi
          });

          document.getElementById('nextPhase').classList.remove('hidden');
        }
      }, 1000);
    }

    function askRecall() {
      currentClick = 0;
      document.getElementById('result').textContent = '';
      document.getElementById('nextPhase').classList.add('hidden');

      cards.forEach((card, index) => {
        const marker = document.createElement('div');
        marker.className = 'absolute text-white font-bold text-xl';
        marker.style.pointerEvents = 'none';
        marker.style.transform = 'translate(-50%, -50%)';
        marker.id = `marker${index}`;
        document.body.appendChild(marker);

        function updateMarkerPosition() {
          const vector = card.position.clone().project(camera);
          const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
          marker.style.left = `${x}px`;
          marker.style.top = `${y}px`;
        }

        card.userData.updateMarker = updateMarkerPosition;
        card.userData.clickable = true;
        card.userData.label = shown[index];
        card.userData.marker = marker;

        card.callback = () => {
          if (!card.userData.clickable) return;

          if (card.userData.label === shown[currentClick]) {
            currentClick++;
            marker.textContent = currentClick;
            if (currentClick === shown.length) {
              document.getElementById('result').textContent = `‚úÖ Kamu berhasil mengingat semuanya!`;
              cards.forEach(c => c.userData.clickable = false);
              cleanupMarkers();
            }
          } else {
            document.getElementById('gameOver').classList.remove('hidden');
            cards.forEach(c => c.userData.clickable = false);
            cleanupMarkers();
          }
        };
      });
    }

    function cleanupMarkers() {
      document.querySelectorAll('[id^="marker"]').forEach(el => el.remove());
      cards.length = 0;
    }

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    canvas.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(cards);
      if (intersects.length > 0) {
        const clicked = intersects[0].object;
        if (clicked.callback) clicked.callback();
      }
    });

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
      cards.forEach(card => {
        if (card.userData.updateMarker) card.userData.updateMarker();
        if (card.userData.updateOrderMarker) card.userData.updateOrderMarker();
      });
    }
    animate();

    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('readyBtn').addEventListener('click', askRecall);
  </script>
</body>
</html>
